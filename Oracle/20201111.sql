-- EQUI JOIN == INNER JOIN 
SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND ENAME = 'SCOTT';

-- NON EQUI JOIN : 동등 비뵤가 아닌 비교연산이 가능 
-- 등급 구하기
SELECT *
FROM EMP E, SALGRADE S 
WHERE E.SAL >= S.LOSAL AND E.SAL <= S.HISAL

-- SELF JOIN 하면 킹은 MGR이 없어서 이런경우 OUTER JOIN 하면됨 
SELECT E.ENAME
FROM EMP E, EMP M 
WHERE e.mgr = M.EMPNO 

-- 같은 의미의 쿼리 두개 
SELECT E.ENAME
FROM EMP E, EMP M 
WHERE e.mgr = M.EMPNO(+) 

SELECT E.ENAME
FROM EMP E LEFT OUTER JOIN EMP M 
ON e.mgr = M.EMPNO ;

-- USING 사용 
SELECT *
FROM EMP JOIN DEPT 
USING(DEPTNO);

-- NATURAL JOIN
SELECT *
  FROM EMP NATURAL JOIN DEPT
  
-- 회원별 구매 횟수
SELECT C.NAME, COUNT(O.ORDERID), SUM(O.SALEPRICE), AVG(O.SALEPRICE)
FROM CUSTOMER C, ORDERS O 
WHERE C.CUSTID = O.CUSTID(+)
GROUP BY C.NAME;


SELECT C.NAME, COUNT(O.ORDERID), SUM(O.SALEPRICE), AVG(O.SALEPRICE)
FROM CUSTOMER C LEFT OUTER JOIN ORDERS O 
ON C.CUSTID = O.CUSTID
GROUP BY C.NAME;


-- 평균 급여보다 더 많은 급여를 받는 사원을 출력
SELECT ENAME, SAL
FROM EMP 
WHERE SAL > (SELECT AVG(SAL) FROM EMP )

-- SAL 3000이상 받는 사원이 소속된 부서 
SELECT *
FROM EMP
WHERE DEPTNO IN( SELECT DISTINCT DEPTNO FROM EMP WHERE SAL >= 3000)

SELECT ENAME, SAL
FROM EMP 
--WHERE SAL > (SELECT MAX(SAL) FROM EMP WHERE DEPTNO=30);
-- 여러개의 정보가 나올경우 ALL 사용
--WHERE SAL > ALL (SELECT SAL FROM EMP WHERE DEPTNO=30);
-- 나온 데이터중 최소값보다 크면 무조건 출력 
WHERE SAL > ANY (SELECT SAL FROM EMP WHERE DEPTNO=30);

-- ROWNUM 
SELECT ROWNUM 
FROM EMP
WHERE ROWNUM < 10;

SELECT ROWNUM, ENAME, HIREDATE
FROM (SELECT ROWNUM, ENAME, HIREDATE FROM EMP ORDER BY HIREDATE DESC)
WHERE ROWNUM < 4

-- 가장 급여를 많이 받는 사원 3명을 출력하자 
SELECT ROWNUM, ENAME, HIREDATE
FROM (SELECT ROWNUM, ENAME, HIREDATE FROM EMP ORDER BY SAL DESC)
WHERE ROWNUM < 4

-- 스칼라 부속 질의 : SELECT 절 프리젠테이션 영역에 쓸수있는 부속질의, 단일행, 단일열, 단일값의 결과만 나와야한다. 
SELECT CUSTID, (SELECT NAME FROM CUSTOMER WHERE CUSTOMER.CUSTID = ORDERS.CUSTID) AS NAME
FROM ORDERS;

-- 마당 서점의 고객별 판매일을 보이시오 (결과는 괙ㄱ이름과 고객별 판매액)
SELECT C.CUSTID, C.NAME, SUM(O.SALEPRICE)
FROM CUSTOMER C, ORDERS O 
WHERE C.CUSTID = O.CUSTID(+)
GROUP BY C.CUSTID, C.NAME
ORDER BY SUM(O.SALEPRICE)

SELECT O.CUSTID, (SELECT NAME FROM CUSTOMER C WHERE O.CUSTID = C.CUSTID), SUM(O.SALEPRICE)
FROM ORDERS O 
GROUP BY O.CUSTID

-- 부속질의 인라인뷰
SELECT C.NAME, SUM(O.SALEPRICE), AVG(O.SALEPRICE)
FROM ORDERS O, (SELECT CUSTID, NAME FROM CUSTOMER WHERE CUSTID <=2) C
WHERE O.CUSTID = C.CUSTID
GROUP BY C.NAME ;

-- 평균 주문금액 이하의 주문에 대해서 주문번호와 금액을 보이시오 
SELECT ORDERID, SALEPRICE
FROM ORDERS
WHERE SALEPRICE <= (SELECT AVG(SALEPRICE) FROM ORDERS);

-- 질의. 각 고객의 평균 주문금액보다 큰 금액의 주문 내역에 대해서 주문번호, 고객번호, 금액을보이시오
SELECT ORDERID, CUSTID, SALEPRICE
FROM ORDERS O1
WHERE SALEPRICE > (SELECT AVG(SALEPRICE) FROM ORDERS O2 WHERE O2.CUSTID=O1.CUSTID)

-- 질의. 대한민국에 거주하는 고객에게 판매한 도서의 총판매액을 구하시오.
SELECT SUM(SALEPRICE)
FROM ORDERS 
WHERE CUSTID IN (SELECT CUSTID FROM CUSTOMER WHERE ADDRESS LIKE '%대한민국%')

-- 질의. 3번 고객이 주문한 도서의 최고 금액보다 더 비싼 도서를 구입한 주문의 주문번호와 금액을 보이시오.
SELECT ORDERID, SALEPRICE 
FROM ORDERS 
--WHERE SALEPRICE > (SELECT MAX(SALEPRICE) FROM ORDERS WHERE CUSTID = 3)
WHERE SALEPRICE > ALL (SELECT SALEPRICE FROM ORDERS WHERE CUSTID = 3)

-- 질의. EXISTS 연산자로 대한민국에 거주하는 고객에게 판매한 도서의 총 판매액을 구하시오.
SELECT SUM(SALEPRICE)
FROM ORDERS O 
WHERE EXISTS (SELECT CUSTID 
                        FROM CUSTOMER C
                        WHERE ADDRESS LIKE '%대한민국%'
                        AND C.CUSTID = O.CUSTID)